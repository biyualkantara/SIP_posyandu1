import { createElementBlock as A, openBlock as y, createElementVNode as K, Fragment as N, renderList as Ee, defineComponent as me, useTemplateRef as le, createCommentVNode as J, createBlock as L, withModifiers as Me, resolveDynamicComponent as _, normalizeClass as B, computed as F, ref as X, shallowRef as mt, watch as ce, getCurrentScope as vt, onScopeDispose as ht, shallowReadonly as re, unref as R, inject as Le, withKeys as gt, renderSlot as yt, mergeModels as Te, useModel as Je, onMounted as bt, onBeforeUnmount as wt, normalizeStyle as xt, withCtx as Ot, createTextVNode as ie, toDisplayString as ue, createVNode as Qe, useSlots as St, useAttrs as Ct, provide as _e, withDirectives as At, mergeProps as kt, vModelDynamic as Rt, Teleport as Dt } from "vue";
const Z = (e, t) => {
  const o = e.__vccOpts || e;
  for (const [n, i] of t)
    o[n] = i;
  return o;
}, Mt = {}, Lt = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor"
};
function Tt(e, t) {
  return y(), A("svg", Lt, [...t[0] || (t[0] = [
    K("path", {
      "fill-rule": "evenodd",
      d: "M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z",
      "clip-rule": "evenodd"
    }, null, -1)
  ])]);
}
const Vt = /* @__PURE__ */ Z(Mt, [["render", Tt]]), Bt = {}, Et = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor"
};
function $t(e, t) {
  return y(), A("svg", Et, [...t[0] || (t[0] = [
    K("path", { d: "M6.28 5.22a.75.75 0 0 0-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 1 0 1.06 1.06L10 11.06l3.72 3.72a.75.75 0 1 0 1.06-1.06L11.06 10l3.72-3.72a.75.75 0 0 0-1.06-1.06L10 8.94 6.28 5.22Z" }, null, -1)
  ])]);
}
const et = /* @__PURE__ */ Z(Bt, [["render", $t]]), Pt = {}, It = { className: "spinner" };
function Ft(e, t) {
  return y(), A("div", It, [
    (y(), A(N, null, Ee(12, (o) => K("div", {
      key: o,
      class: "spinner-circle"
    })), 64))
  ]);
}
const Nt = /* @__PURE__ */ Z(Pt, [["render", Ft], ["__scopeId", "data-v-ed866313"]]), Wt = {
  ref: "container",
  class: "indicators-container"
}, _t = ["disabled"], Ht = ["disabled"], zt = /* @__PURE__ */ me({
  __name: "Indicators",
  props: {
    hasSelectedOption: { type: Boolean },
    isMenuOpen: { type: Boolean },
    isClearable: { type: Boolean },
    isLoading: { type: Boolean },
    isDisabled: { type: Boolean },
    slots: {}
  },
  emits: ["clear", "toggle"],
  setup(e, { expose: t, emit: o }) {
    const n = e, i = o, s = le("container"), l = le("clearButton"), c = le("dropdownButton");
    return t({ containerRef: s, clearButtonRef: l, dropdownButtonRef: c }), (f, u) => (y(), A("div", Wt, [
      e.hasSelectedOption && e.isClearable && !e.isLoading ? (y(), A("button", {
        key: 0,
        ref: "clearButton",
        type: "button",
        class: "clear-button",
        disabled: e.isDisabled,
        onClick: u[0] || (u[0] = Me((r) => i("clear"), ["stop"]))
      }, [
        n.slots.clear ? (y(), L(_(n.slots.clear), { key: 0 })) : (y(), L(et, { key: 1 }))
      ], 8, _t)) : J("", !0),
      e.isLoading ? J("", !0) : (y(), A("button", {
        key: 1,
        ref: "dropdownButton",
        type: "button",
        class: B(["dropdown-icon", { active: e.isMenuOpen }]),
        disabled: e.isDisabled,
        onClick: u[1] || (u[1] = Me((r) => i("toggle"), ["stop"]))
      }, [
        n.slots.dropdown ? (y(), L(_(n.slots.dropdown), { key: 0 })) : (y(), L(Vt, { key: 1 }))
      ], 10, Ht)),
      n.slots.loading ? (y(), L(_(n.slots.loading), { key: 2 })) : (y(), A(N, { key: 3 }, [
        e.isLoading ? (y(), L(Nt, { key: 0 })) : J("", !0)
      ], 64))
    ], 512));
  }
}), jt = /* @__PURE__ */ Z(zt, [["__scopeId", "data-v-2d0f5223"]]), tt = Symbol("props"), $e = Symbol("data");
let qt = 0;
function Ut() {
  return ++qt;
}
const fe = Math.min, $ = Math.max, xe = Math.round, we = Math.floor, j = (e) => ({
  x: e,
  y: e
}), Xt = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Kt = {
  start: "end",
  end: "start"
};
function He(e, t, o) {
  return $(e, fe(t, o));
}
function ge(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Q(e) {
  return e.split("-")[0];
}
function ye(e) {
  return e.split("-")[1];
}
function nt(e) {
  return e === "x" ? "y" : "x";
}
function ot(e) {
  return e === "y" ? "height" : "width";
}
const Yt = /* @__PURE__ */ new Set(["top", "bottom"]);
function Y(e) {
  return Yt.has(Q(e)) ? "y" : "x";
}
function it(e) {
  return nt(Y(e));
}
function Zt(e, t, o) {
  o === void 0 && (o = !1);
  const n = ye(e), i = it(e), s = ot(i);
  let l = i === "x" ? n === (o ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (l = Oe(l)), [l, Oe(l)];
}
function Gt(e) {
  const t = Oe(e);
  return [Ve(e), t, Ve(t)];
}
function Ve(e) {
  return e.replace(/start|end/g, (t) => Kt[t]);
}
const ze = ["left", "right"], je = ["right", "left"], Jt = ["top", "bottom"], Qt = ["bottom", "top"];
function en(e, t, o) {
  switch (e) {
    case "top":
    case "bottom":
      return o ? t ? je : ze : t ? ze : je;
    case "left":
    case "right":
      return t ? Jt : Qt;
    default:
      return [];
  }
}
function tn(e, t, o, n) {
  const i = ye(e);
  let s = en(Q(e), o === "start", n);
  return i && (s = s.map((l) => l + "-" + i), t && (s = s.concat(s.map(Ve)))), s;
}
function Oe(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Xt[t]);
}
function nn(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function on(e) {
  return typeof e != "number" ? nn(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Se(e) {
  const {
    x: t,
    y: o,
    width: n,
    height: i
  } = e;
  return {
    width: n,
    height: i,
    top: o,
    left: t,
    right: t + n,
    bottom: o + i,
    x: t,
    y: o
  };
}
function qe(e, t, o) {
  let {
    reference: n,
    floating: i
  } = e;
  const s = Y(t), l = it(t), c = ot(l), f = Q(t), u = s === "y", r = n.x + n.width / 2 - i.width / 2, p = n.y + n.height / 2 - i.height / 2, d = n[c] / 2 - i[c] / 2;
  let a;
  switch (f) {
    case "top":
      a = {
        x: r,
        y: n.y - i.height
      };
      break;
    case "bottom":
      a = {
        x: r,
        y: n.y + n.height
      };
      break;
    case "right":
      a = {
        x: n.x + n.width,
        y: p
      };
      break;
    case "left":
      a = {
        x: n.x - i.width,
        y: p
      };
      break;
    default:
      a = {
        x: n.x,
        y: n.y
      };
  }
  switch (ye(t)) {
    case "start":
      a[l] -= d * (o && u ? -1 : 1);
      break;
    case "end":
      a[l] += d * (o && u ? -1 : 1);
      break;
  }
  return a;
}
const ln = async (e, t, o) => {
  const {
    placement: n = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: l
  } = o, c = s.filter(Boolean), f = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let u = await l.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: r,
    y: p
  } = qe(u, n, f), d = n, a = {}, m = 0;
  for (let g = 0; g < c.length; g++) {
    const {
      name: v,
      fn: w
    } = c[g], {
      x: b,
      y: x,
      data: D,
      reset: k
    } = await w({
      x: r,
      y: p,
      initialPlacement: n,
      placement: d,
      strategy: i,
      middlewareData: a,
      rects: u,
      platform: l,
      elements: {
        reference: e,
        floating: t
      }
    });
    r = b ?? r, p = x ?? p, a = {
      ...a,
      [v]: {
        ...a[v],
        ...D
      }
    }, k && m <= 50 && (m++, typeof k == "object" && (k.placement && (d = k.placement), k.rects && (u = k.rects === !0 ? await l.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : k.rects), {
      x: r,
      y: p
    } = qe(u, d, f)), g = -1);
  }
  return {
    x: r,
    y: p,
    placement: d,
    strategy: i,
    middlewareData: a
  };
};
async function Pe(e, t) {
  var o;
  t === void 0 && (t = {});
  const {
    x: n,
    y: i,
    platform: s,
    rects: l,
    elements: c,
    strategy: f
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: r = "viewport",
    elementContext: p = "floating",
    altBoundary: d = !1,
    padding: a = 0
  } = ge(t, e), m = on(a), v = c[d ? p === "floating" ? "reference" : "floating" : p], w = Se(await s.getClippingRect({
    element: (o = await (s.isElement == null ? void 0 : s.isElement(v))) == null || o ? v : v.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(c.floating)),
    boundary: u,
    rootBoundary: r,
    strategy: f
  })), b = p === "floating" ? {
    x: n,
    y: i,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, x = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c.floating)), D = await (s.isElement == null ? void 0 : s.isElement(x)) ? await (s.getScale == null ? void 0 : s.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, k = Se(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: b,
    offsetParent: x,
    strategy: f
  }) : b);
  return {
    top: (w.top - k.top + m.top) / D.y,
    bottom: (k.bottom - w.bottom + m.bottom) / D.y,
    left: (w.left - k.left + m.left) / D.x,
    right: (k.right - w.right + m.right) / D.x
  };
}
const sn = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var o, n;
      const {
        placement: i,
        middlewareData: s,
        rects: l,
        initialPlacement: c,
        platform: f,
        elements: u
      } = t, {
        mainAxis: r = !0,
        crossAxis: p = !0,
        fallbackPlacements: d,
        fallbackStrategy: a = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: g = !0,
        ...v
      } = ge(e, t);
      if ((o = s.arrow) != null && o.alignmentOffset)
        return {};
      const w = Q(i), b = Y(c), x = Q(c) === c, D = await (f.isRTL == null ? void 0 : f.isRTL(u.floating)), k = d || (x || !g ? [Oe(c)] : Gt(c)), I = m !== "none";
      !d && I && k.push(...tn(c, g, m, D));
      const O = [c, ...k], M = await Pe(t, v), E = [];
      let W = ((n = s.flip) == null ? void 0 : n.overflows) || [];
      if (r && E.push(M[w]), p) {
        const h = Zt(i, l, D);
        E.push(M[h[0]], M[h[1]]);
      }
      if (W = [...W, {
        placement: i,
        overflows: E
      }], !E.every((h) => h <= 0)) {
        var te, ne;
        const h = (((te = s.flip) == null ? void 0 : te.index) || 0) + 1, S = O[h];
        if (S && (!(p === "alignment" ? b !== Y(S) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        W.every((V) => Y(V.placement) === b ? V.overflows[0] > 0 : !0)))
          return {
            data: {
              index: h,
              overflows: W
            },
            reset: {
              placement: S
            }
          };
        let C = (ne = W.filter((T) => T.overflows[0] <= 0).sort((T, V) => T.overflows[1] - V.overflows[1])[0]) == null ? void 0 : ne.placement;
        if (!C)
          switch (a) {
            case "bestFit": {
              var oe;
              const T = (oe = W.filter((V) => {
                if (I) {
                  const G = Y(V.placement);
                  return G === b || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  G === "y";
                }
                return !0;
              }).map((V) => [V.placement, V.overflows.filter((G) => G > 0).reduce((G, pt) => G + pt, 0)]).sort((V, G) => V[1] - G[1])[0]) == null ? void 0 : oe[0];
              T && (C = T);
              break;
            }
            case "initialPlacement":
              C = c;
              break;
          }
        if (i !== C)
          return {
            reset: {
              placement: C
            }
          };
      }
      return {};
    }
  };
}, an = /* @__PURE__ */ new Set(["left", "top"]);
async function rn(e, t) {
  const {
    placement: o,
    platform: n,
    elements: i
  } = e, s = await (n.isRTL == null ? void 0 : n.isRTL(i.floating)), l = Q(o), c = ye(o), f = Y(o) === "y", u = an.has(l) ? -1 : 1, r = s && f ? -1 : 1, p = ge(t, e);
  let {
    mainAxis: d,
    crossAxis: a,
    alignmentAxis: m
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: p.mainAxis || 0,
    crossAxis: p.crossAxis || 0,
    alignmentAxis: p.alignmentAxis
  };
  return c && typeof m == "number" && (a = c === "end" ? m * -1 : m), f ? {
    x: a * r,
    y: d * u
  } : {
    x: d * u,
    y: a * r
  };
}
const cn = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var o, n;
      const {
        x: i,
        y: s,
        placement: l,
        middlewareData: c
      } = t, f = await rn(t, e);
      return l === ((o = c.offset) == null ? void 0 : o.placement) && (n = c.arrow) != null && n.alignmentOffset ? {} : {
        x: i + f.x,
        y: s + f.y,
        data: {
          ...f,
          placement: l
        }
      };
    }
  };
}, un = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: o,
        y: n,
        placement: i
      } = t, {
        mainAxis: s = !0,
        crossAxis: l = !1,
        limiter: c = {
          fn: (v) => {
            let {
              x: w,
              y: b
            } = v;
            return {
              x: w,
              y: b
            };
          }
        },
        ...f
      } = ge(e, t), u = {
        x: o,
        y: n
      }, r = await Pe(t, f), p = Y(Q(i)), d = nt(p);
      let a = u[d], m = u[p];
      if (s) {
        const v = d === "y" ? "top" : "left", w = d === "y" ? "bottom" : "right", b = a + r[v], x = a - r[w];
        a = He(b, a, x);
      }
      if (l) {
        const v = p === "y" ? "top" : "left", w = p === "y" ? "bottom" : "right", b = m + r[v], x = m - r[w];
        m = He(b, m, x);
      }
      const g = c.fn({
        ...t,
        [d]: a,
        [p]: m
      });
      return {
        ...g,
        data: {
          x: g.x - o,
          y: g.y - n,
          enabled: {
            [d]: s,
            [p]: l
          }
        }
      };
    }
  };
}, dn = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var o, n;
      const {
        placement: i,
        rects: s,
        platform: l,
        elements: c
      } = t, {
        apply: f = () => {
        },
        ...u
      } = ge(e, t), r = await Pe(t, u), p = Q(i), d = ye(i), a = Y(i) === "y", {
        width: m,
        height: g
      } = s.floating;
      let v, w;
      p === "top" || p === "bottom" ? (v = p, w = d === (await (l.isRTL == null ? void 0 : l.isRTL(c.floating)) ? "start" : "end") ? "left" : "right") : (w = p, v = d === "end" ? "top" : "bottom");
      const b = g - r.top - r.bottom, x = m - r.left - r.right, D = fe(g - r[v], b), k = fe(m - r[w], x), I = !t.middlewareData.shift;
      let O = D, M = k;
      if ((o = t.middlewareData.shift) != null && o.enabled.x && (M = x), (n = t.middlewareData.shift) != null && n.enabled.y && (O = b), I && !d) {
        const W = $(r.left, 0), te = $(r.right, 0), ne = $(r.top, 0), oe = $(r.bottom, 0);
        a ? M = m - 2 * (W !== 0 || te !== 0 ? W + te : $(r.left, r.right)) : O = g - 2 * (ne !== 0 || oe !== 0 ? ne + oe : $(r.top, r.bottom));
      }
      await f({
        ...t,
        availableWidth: M,
        availableHeight: O
      });
      const E = await l.getDimensions(c.floating);
      return m !== E.width || g !== E.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Ce() {
  return typeof window < "u";
}
function ae(e) {
  return Ie(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function P(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function U(e) {
  var t;
  return (t = (Ie(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Ie(e) {
  return Ce() ? e instanceof Node || e instanceof P(e).Node : !1;
}
function H(e) {
  return Ce() ? e instanceof Element || e instanceof P(e).Element : !1;
}
function q(e) {
  return Ce() ? e instanceof HTMLElement || e instanceof P(e).HTMLElement : !1;
}
function Ue(e) {
  return !Ce() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof P(e).ShadowRoot;
}
const fn = /* @__PURE__ */ new Set(["inline", "contents"]);
function be(e) {
  const {
    overflow: t,
    overflowX: o,
    overflowY: n,
    display: i
  } = z(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + n + o) && !fn.has(i);
}
const pn = /* @__PURE__ */ new Set(["table", "td", "th"]);
function mn(e) {
  return pn.has(ae(e));
}
const vn = [":popover-open", ":modal"];
function Ae(e) {
  return vn.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const hn = ["transform", "translate", "scale", "rotate", "perspective"], gn = ["transform", "translate", "scale", "rotate", "perspective", "filter"], yn = ["paint", "layout", "strict", "content"];
function Fe(e) {
  const t = Ne(), o = H(e) ? z(e) : e;
  return hn.some((n) => o[n] ? o[n] !== "none" : !1) || (o.containerType ? o.containerType !== "normal" : !1) || !t && (o.backdropFilter ? o.backdropFilter !== "none" : !1) || !t && (o.filter ? o.filter !== "none" : !1) || gn.some((n) => (o.willChange || "").includes(n)) || yn.some((n) => (o.contain || "").includes(n));
}
function bn(e) {
  let t = ee(e);
  for (; q(t) && !pe(t); ) {
    if (Fe(t))
      return t;
    if (Ae(t))
      return null;
    t = ee(t);
  }
  return null;
}
function Ne() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const wn = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function pe(e) {
  return wn.has(ae(e));
}
function z(e) {
  return P(e).getComputedStyle(e);
}
function ke(e) {
  return H(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function ee(e) {
  if (ae(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Ue(e) && e.host || // Fallback.
    U(e)
  );
  return Ue(t) ? t.host : t;
}
function lt(e) {
  const t = ee(e);
  return pe(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : q(t) && be(t) ? t : lt(t);
}
function he(e, t, o) {
  var n;
  t === void 0 && (t = []), o === void 0 && (o = !0);
  const i = lt(e), s = i === ((n = e.ownerDocument) == null ? void 0 : n.body), l = P(i);
  if (s) {
    const c = Be(l);
    return t.concat(l, l.visualViewport || [], be(i) ? i : [], c && o ? he(c) : []);
  }
  return t.concat(i, he(i, [], o));
}
function Be(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function st(e) {
  const t = z(e);
  let o = parseFloat(t.width) || 0, n = parseFloat(t.height) || 0;
  const i = q(e), s = i ? e.offsetWidth : o, l = i ? e.offsetHeight : n, c = xe(o) !== s || xe(n) !== l;
  return c && (o = s, n = l), {
    width: o,
    height: n,
    $: c
  };
}
function We(e) {
  return H(e) ? e : e.contextElement;
}
function de(e) {
  const t = We(e);
  if (!q(t))
    return j(1);
  const o = t.getBoundingClientRect(), {
    width: n,
    height: i,
    $: s
  } = st(t);
  let l = (s ? xe(o.width) : o.width) / n, c = (s ? xe(o.height) : o.height) / i;
  return (!l || !Number.isFinite(l)) && (l = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: l,
    y: c
  };
}
const xn = /* @__PURE__ */ j(0);
function at(e) {
  const t = P(e);
  return !Ne() || !t.visualViewport ? xn : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function On(e, t, o) {
  return t === void 0 && (t = !1), !o || t && o !== P(e) ? !1 : t;
}
function se(e, t, o, n) {
  t === void 0 && (t = !1), o === void 0 && (o = !1);
  const i = e.getBoundingClientRect(), s = We(e);
  let l = j(1);
  t && (n ? H(n) && (l = de(n)) : l = de(e));
  const c = On(s, o, n) ? at(s) : j(0);
  let f = (i.left + c.x) / l.x, u = (i.top + c.y) / l.y, r = i.width / l.x, p = i.height / l.y;
  if (s) {
    const d = P(s), a = n && H(n) ? P(n) : n;
    let m = d, g = Be(m);
    for (; g && n && a !== m; ) {
      const v = de(g), w = g.getBoundingClientRect(), b = z(g), x = w.left + (g.clientLeft + parseFloat(b.paddingLeft)) * v.x, D = w.top + (g.clientTop + parseFloat(b.paddingTop)) * v.y;
      f *= v.x, u *= v.y, r *= v.x, p *= v.y, f += x, u += D, m = P(g), g = Be(m);
    }
  }
  return Se({
    width: r,
    height: p,
    x: f,
    y: u
  });
}
function Re(e, t) {
  const o = ke(e).scrollLeft;
  return t ? t.left + o : se(U(e)).left + o;
}
function rt(e, t) {
  const o = e.getBoundingClientRect(), n = o.left + t.scrollLeft - Re(e, o), i = o.top + t.scrollTop;
  return {
    x: n,
    y: i
  };
}
function Sn(e) {
  let {
    elements: t,
    rect: o,
    offsetParent: n,
    strategy: i
  } = e;
  const s = i === "fixed", l = U(n), c = t ? Ae(t.floating) : !1;
  if (n === l || c && s)
    return o;
  let f = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = j(1);
  const r = j(0), p = q(n);
  if ((p || !p && !s) && ((ae(n) !== "body" || be(l)) && (f = ke(n)), q(n))) {
    const a = se(n);
    u = de(n), r.x = a.x + n.clientLeft, r.y = a.y + n.clientTop;
  }
  const d = l && !p && !s ? rt(l, f) : j(0);
  return {
    width: o.width * u.x,
    height: o.height * u.y,
    x: o.x * u.x - f.scrollLeft * u.x + r.x + d.x,
    y: o.y * u.y - f.scrollTop * u.y + r.y + d.y
  };
}
function Cn(e) {
  return Array.from(e.getClientRects());
}
function An(e) {
  const t = U(e), o = ke(e), n = e.ownerDocument.body, i = $(t.scrollWidth, t.clientWidth, n.scrollWidth, n.clientWidth), s = $(t.scrollHeight, t.clientHeight, n.scrollHeight, n.clientHeight);
  let l = -o.scrollLeft + Re(e);
  const c = -o.scrollTop;
  return z(n).direction === "rtl" && (l += $(t.clientWidth, n.clientWidth) - i), {
    width: i,
    height: s,
    x: l,
    y: c
  };
}
const Xe = 25;
function kn(e, t) {
  const o = P(e), n = U(e), i = o.visualViewport;
  let s = n.clientWidth, l = n.clientHeight, c = 0, f = 0;
  if (i) {
    s = i.width, l = i.height;
    const r = Ne();
    (!r || r && t === "fixed") && (c = i.offsetLeft, f = i.offsetTop);
  }
  const u = Re(n);
  if (u <= 0) {
    const r = n.ownerDocument, p = r.body, d = getComputedStyle(p), a = r.compatMode === "CSS1Compat" && parseFloat(d.marginLeft) + parseFloat(d.marginRight) || 0, m = Math.abs(n.clientWidth - p.clientWidth - a);
    m <= Xe && (s -= m);
  } else u <= Xe && (s += u);
  return {
    width: s,
    height: l,
    x: c,
    y: f
  };
}
const Rn = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Dn(e, t) {
  const o = se(e, !0, t === "fixed"), n = o.top + e.clientTop, i = o.left + e.clientLeft, s = q(e) ? de(e) : j(1), l = e.clientWidth * s.x, c = e.clientHeight * s.y, f = i * s.x, u = n * s.y;
  return {
    width: l,
    height: c,
    x: f,
    y: u
  };
}
function Ke(e, t, o) {
  let n;
  if (t === "viewport")
    n = kn(e, o);
  else if (t === "document")
    n = An(U(e));
  else if (H(t))
    n = Dn(t, o);
  else {
    const i = at(e);
    n = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return Se(n);
}
function ct(e, t) {
  const o = ee(e);
  return o === t || !H(o) || pe(o) ? !1 : z(o).position === "fixed" || ct(o, t);
}
function Mn(e, t) {
  const o = t.get(e);
  if (o)
    return o;
  let n = he(e, [], !1).filter((c) => H(c) && ae(c) !== "body"), i = null;
  const s = z(e).position === "fixed";
  let l = s ? ee(e) : e;
  for (; H(l) && !pe(l); ) {
    const c = z(l), f = Fe(l);
    !f && c.position === "fixed" && (i = null), (s ? !f && !i : !f && c.position === "static" && !!i && Rn.has(i.position) || be(l) && !f && ct(e, l)) ? n = n.filter((r) => r !== l) : i = c, l = ee(l);
  }
  return t.set(e, n), n;
}
function Ln(e) {
  let {
    element: t,
    boundary: o,
    rootBoundary: n,
    strategy: i
  } = e;
  const l = [...o === "clippingAncestors" ? Ae(t) ? [] : Mn(t, this._c) : [].concat(o), n], c = l[0], f = l.reduce((u, r) => {
    const p = Ke(t, r, i);
    return u.top = $(p.top, u.top), u.right = fe(p.right, u.right), u.bottom = fe(p.bottom, u.bottom), u.left = $(p.left, u.left), u;
  }, Ke(t, c, i));
  return {
    width: f.right - f.left,
    height: f.bottom - f.top,
    x: f.left,
    y: f.top
  };
}
function Tn(e) {
  const {
    width: t,
    height: o
  } = st(e);
  return {
    width: t,
    height: o
  };
}
function Vn(e, t, o) {
  const n = q(t), i = U(t), s = o === "fixed", l = se(e, !0, s, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const f = j(0);
  function u() {
    f.x = Re(i);
  }
  if (n || !n && !s)
    if ((ae(t) !== "body" || be(i)) && (c = ke(t)), n) {
      const a = se(t, !0, s, t);
      f.x = a.x + t.clientLeft, f.y = a.y + t.clientTop;
    } else i && u();
  s && !n && i && u();
  const r = i && !n && !s ? rt(i, c) : j(0), p = l.left + c.scrollLeft - f.x - r.x, d = l.top + c.scrollTop - f.y - r.y;
  return {
    x: p,
    y: d,
    width: l.width,
    height: l.height
  };
}
function De(e) {
  return z(e).position === "static";
}
function Ye(e, t) {
  if (!q(e) || z(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let o = e.offsetParent;
  return U(e) === o && (o = o.ownerDocument.body), o;
}
function ut(e, t) {
  const o = P(e);
  if (Ae(e))
    return o;
  if (!q(e)) {
    let i = ee(e);
    for (; i && !pe(i); ) {
      if (H(i) && !De(i))
        return i;
      i = ee(i);
    }
    return o;
  }
  let n = Ye(e, t);
  for (; n && mn(n) && De(n); )
    n = Ye(n, t);
  return n && pe(n) && De(n) && !Fe(n) ? o : n || bn(e) || o;
}
const Bn = async function(e) {
  const t = this.getOffsetParent || ut, o = this.getDimensions, n = await o(e.floating);
  return {
    reference: Vn(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function En(e) {
  return z(e).direction === "rtl";
}
const $n = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Sn,
  getDocumentElement: U,
  getClippingRect: Ln,
  getOffsetParent: ut,
  getElementRects: Bn,
  getClientRects: Cn,
  getDimensions: Tn,
  getScale: de,
  isElement: H,
  isRTL: En
};
function dt(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function Pn(e, t) {
  let o = null, n;
  const i = U(e);
  function s() {
    var c;
    clearTimeout(n), (c = o) == null || c.disconnect(), o = null;
  }
  function l(c, f) {
    c === void 0 && (c = !1), f === void 0 && (f = 1), s();
    const u = e.getBoundingClientRect(), {
      left: r,
      top: p,
      width: d,
      height: a
    } = u;
    if (c || t(), !d || !a)
      return;
    const m = we(p), g = we(i.clientWidth - (r + d)), v = we(i.clientHeight - (p + a)), w = we(r), x = {
      rootMargin: -m + "px " + -g + "px " + -v + "px " + -w + "px",
      threshold: $(0, fe(1, f)) || 1
    };
    let D = !0;
    function k(I) {
      const O = I[0].intersectionRatio;
      if (O !== f) {
        if (!D)
          return l();
        O ? l(!1, O) : n = setTimeout(() => {
          l(!1, 1e-7);
        }, 1e3);
      }
      O === 1 && !dt(u, e.getBoundingClientRect()) && l(), D = !1;
    }
    try {
      o = new IntersectionObserver(k, {
        ...x,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      o = new IntersectionObserver(k, x);
    }
    o.observe(e);
  }
  return l(!0), s;
}
function In(e, t, o, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: s = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: f = !1
  } = n, u = We(e), r = i || s ? [...u ? he(u) : [], ...he(t)] : [];
  r.forEach((w) => {
    i && w.addEventListener("scroll", o, {
      passive: !0
    }), s && w.addEventListener("resize", o);
  });
  const p = u && c ? Pn(u, o) : null;
  let d = -1, a = null;
  l && (a = new ResizeObserver((w) => {
    let [b] = w;
    b && b.target === u && a && (a.unobserve(t), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var x;
      (x = a) == null || x.observe(t);
    })), o();
  }), u && !f && a.observe(u), a.observe(t));
  let m, g = f ? se(e) : null;
  f && v();
  function v() {
    const w = se(e);
    g && !dt(g, w) && o(), g = w, m = requestAnimationFrame(v);
  }
  return o(), () => {
    var w;
    r.forEach((b) => {
      i && b.removeEventListener("scroll", o), s && b.removeEventListener("resize", o);
    }), p?.(), (w = a) == null || w.disconnect(), a = null, f && cancelAnimationFrame(m);
  };
}
const Fn = cn, Nn = un, Wn = sn, _n = dn, Hn = (e, t, o) => {
  const n = /* @__PURE__ */ new Map(), i = {
    platform: $n,
    ...o
  }, s = {
    ...i.platform,
    _c: n
  };
  return ln(e, t, {
    ...i,
    platform: s
  });
};
function zn(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function Ze(e) {
  if (zn(e)) {
    const t = e.$el;
    return Ie(t) && ae(t) === "#comment" ? null : t;
  }
  return e;
}
function ve(e) {
  return typeof e == "function" ? e() : R(e);
}
function ft(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Ge(e, t) {
  const o = ft(e);
  return Math.round(t * o) / o;
}
function jn(e, t, o) {
  o === void 0 && (o = {});
  const n = o.whileElementsMounted, i = F(() => {
    var O;
    return (O = ve(o.open)) != null ? O : !0;
  }), s = F(() => ve(o.middleware)), l = F(() => {
    var O;
    return (O = ve(o.placement)) != null ? O : "bottom";
  }), c = F(() => {
    var O;
    return (O = ve(o.strategy)) != null ? O : "absolute";
  }), f = F(() => {
    var O;
    return (O = ve(o.transform)) != null ? O : !0;
  }), u = F(() => Ze(e.value)), r = F(() => Ze(t.value)), p = X(0), d = X(0), a = X(c.value), m = X(l.value), g = mt({}), v = X(!1), w = F(() => {
    const O = {
      position: a.value,
      left: "0",
      top: "0"
    };
    if (!r.value)
      return O;
    const M = Ge(r.value, p.value), E = Ge(r.value, d.value);
    return f.value ? {
      ...O,
      transform: "translate(" + M + "px, " + E + "px)",
      ...ft(r.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: a.value,
      left: M + "px",
      top: E + "px"
    };
  });
  let b;
  function x() {
    if (u.value == null || r.value == null)
      return;
    const O = i.value;
    Hn(u.value, r.value, {
      middleware: s.value,
      placement: l.value,
      strategy: c.value
    }).then((M) => {
      p.value = M.x, d.value = M.y, a.value = M.strategy, m.value = M.placement, g.value = M.middlewareData, v.value = O !== !1;
    });
  }
  function D() {
    typeof b == "function" && (b(), b = void 0);
  }
  function k() {
    if (D(), n === void 0) {
      x();
      return;
    }
    if (u.value != null && r.value != null) {
      b = n(u.value, r.value, x);
      return;
    }
  }
  function I() {
    i.value || (v.value = !1);
  }
  return ce([s, l, c, i], x, {
    flush: "sync"
  }), ce([u, r], k, {
    flush: "sync"
  }), ce(i, I, {
    flush: "sync"
  }), vt() && ht(D), {
    x: re(p),
    y: re(d),
    strategy: re(a),
    placement: re(m),
    middlewareData: re(g),
    isPositioned: re(v),
    floatingStyles: w,
    update: x
  };
}
const qn = ["aria-disabled", "aria-selected"], Un = /* @__PURE__ */ me({
  __name: "MenuOption",
  props: {
    menu: {},
    index: {},
    isFocused: { type: Boolean },
    isSelected: { type: Boolean },
    isDisabled: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const o = e, n = t, i = Le($e), s = () => {
      !o.isDisabled && i?.setFocusedOption && i.setFocusedOption(o.index);
    }, l = X(null);
    return ce(
      () => o.isFocused,
      () => {
        if (o.isFocused && o.menu) {
          const c = o.menu.children[o.index], f = c.offsetTop, u = f + c.clientHeight, r = o.menu.scrollTop, p = o.menu.clientHeight;
          f < r ? o.menu.scrollTop = f : u > r + p && (o.menu.scrollTop = u - p);
        }
      }
    ), (c, f) => (y(), A("div", {
      ref_key: "option",
      ref: l,
      class: B(["menu-option", { focused: e.isFocused, selected: e.isSelected, disabled: e.isDisabled }]),
      role: "option",
      "aria-disabled": e.isDisabled,
      "aria-selected": e.isSelected,
      onClick: f[0] || (f[0] = (u) => n("select")),
      onKeydown: f[1] || (f[1] = gt((u) => n("select"), ["enter"])),
      onMouseenter: s
    }, [
      yt(c.$slots, "default", {}, void 0, !0)
    ], 42, qn));
  }
}), Xn = /* @__PURE__ */ Z(Un, [["__scopeId", "data-v-52c71ffd"]]), Kn = ["id", "aria-label", "aria-multiselectable", "data-state-position"], Yn = /* @__PURE__ */ me({
  __name: "Menu",
  props: /* @__PURE__ */ Te({
    slots: {},
    rootClass: {}
  }, {
    modelValue: { required: !0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = e, o = Je(e, "modelValue"), n = Le(tt), i = Le($e), s = le("menu"), { floatingStyles: l, placement: c } = jn(i.containerRef, s, {
      whileElementsMounted: In,
      placement: "bottom-start",
      middleware: [
        Wn(),
        Fn(5),
        Nn(),
        _n({
          apply({ elements: r, rects: p }) {
            Object.assign(r.floating.style, {
              width: `${Math.max(0, p.reference.width)}px`
            });
          }
        })
      ]
    }), f = (r) => {
      if (i.menuOpen.value) {
        const p = i.focusedOption.value;
        if (r.key === "ArrowDown") {
          r.preventDefault();
          const a = i.availableOptions.value.findIndex((g, v) => !g.disabled && v > p), m = i.availableOptions.value.findIndex((g) => !g.disabled);
          i.focusedOption.value = a === -1 ? m : a;
        }
        if (r.key === "ArrowUp") {
          r.preventDefault();
          const a = i.availableOptions.value.reduce(
            (g, v, w) => !v.disabled && w < p ? w : g,
            -1
          ), m = i.availableOptions.value.reduce(
            (g, v, w) => v.disabled ? g : w,
            -1
          );
          i.focusedOption.value = a === -1 ? m : a;
        }
        if (r.key === "Enter") {
          const a = i.availableOptions.value[p];
          r.preventDefault(), a ? i.setOption(a) : n.isTaggable && i.search.value && i.createOption();
        }
        if (r.code === "Space" && i.search.value.length === 0) {
          const a = i.availableOptions.value[p];
          r.preventDefault(), a && i.setOption(a);
        }
        if (r.key === "Escape" && (r.preventDefault(), i.closeMenu()), r.key === "PageDown") {
          r.preventDefault();
          const a = i.availableOptions.value.reduce(
            (m, g, v) => g.disabled ? m : v,
            -1
          );
          i.focusedOption.value = a;
        }
        if (r.key === "PageUp") {
          r.preventDefault();
          const a = i.availableOptions.value.findIndex((m) => !m.disabled);
          i.focusedOption.value = a;
        }
        const d = n.isMulti && Array.isArray(o.value) ? o.value.length > 0 : !!o.value;
        if (r.key === "Backspace" && i.search.value.length === 0 && d)
          if (r.preventDefault(), n.isMulti) {
            const a = i.selectedOptions.value, m = a[a.length - 1];
            m && i.removeOption(m);
          } else {
            const a = i.selectedOptions.value[0];
            a && i.removeOption(a);
          }
      }
    }, u = (r) => {
      const p = r.target, d = i.containerRef.value && i.containerRef.value.contains(p), a = s.value && s.value.contains(p);
      !d && !a && i.closeMenu();
    };
    return bt(() => {
      document.addEventListener("keydown", f), document.addEventListener("click", u);
    }), wt(() => {
      document.removeEventListener("keydown", f), document.removeEventListener("click", u);
    }), (r, p) => (y(), A("div", {
      id: `vue-select-${R(n).uid}-listbox`,
      ref: "menu",
      class: B(["menu", [R(n).classes?.menuContainer, t.rootClass]]),
      role: "listbox",
      "aria-label": R(n).aria?.labelledby,
      "aria-multiselectable": R(n).isMulti,
      "data-state-position": R(c),
      style: xt({
        ...R(l)
      })
    }, [
      t.slots["menu-header"] ? (y(), L(_(t.slots["menu-header"]), { key: 0 })) : J("", !0),
      (y(!0), A(N, null, Ee(R(i).availableOptions.value, (d, a) => (y(), L(Xn, {
        key: a,
        type: "button",
        menu: s.value,
        index: a,
        "is-focused": R(i).focusedOption.value === a,
        "is-selected": Array.isArray(o.value) ? o.value.includes(d.value) : d.value === o.value,
        "is-disabled": d.disabled || !1,
        class: B(R(n).classes?.menuOption),
        onSelect: (m) => R(i).setOption(d)
      }, {
        default: Ot(() => [
          t.slots.option ? (y(), L(_(t.slots.option), {
            key: 0,
            option: d,
            index: a,
            "is-focused": R(i).focusedOption.value === a,
            "is-selected": Array.isArray(o.value) ? o.value.includes(d.value) : d.value === o.value,
            "is-disabled": d.disabled || !1
          }, null, 8, ["option", "index", "is-focused", "is-selected", "is-disabled"])) : R(n).getOptionLabel ? (y(), A(N, { key: 1 }, [
            ie(ue(R(n).getOptionLabel(d)), 1)
          ], 64)) : (y(), A(N, { key: 2 }, [
            ie(ue(d.label), 1)
          ], 64))
        ]),
        _: 2
      }, 1032, ["menu", "index", "is-focused", "is-selected", "is-disabled", "class", "onSelect"]))), 128)),
      !R(n).isTaggable && R(i).availableOptions.value.length === 0 ? (y(), A("div", {
        key: 1,
        class: B(["no-results", R(n).classes?.noResults])
      }, [
        t.slots["no-options"] ? (y(), L(_(t.slots["no-options"]), { key: 0 })) : (y(), A(N, { key: 1 }, [
          ie(" No results found ")
        ], 64))
      ], 2)) : J("", !0),
      R(n).isTaggable && R(i).search.value ? (y(), A("div", {
        key: 2,
        class: B(["taggable-no-options", R(n).classes?.taggableNoOptions]),
        onClick: p[0] || (p[0] = //@ts-ignore
        (...d) => R(i).createOption && R(i).createOption(...d))
      }, [
        t.slots["taggable-no-options"] ? (y(), L(_(t.slots["taggable-no-options"]), {
          key: 0,
          option: R(i).search.value
        }, null, 8, ["option"])) : (y(), A(N, { key: 1 }, [
          ie(" Press enter to add " + ue(R(i).search.value) + " option ", 1)
        ], 64))
      ], 2)) : J("", !0)
    ], 14, Kn));
  }
}), Zn = /* @__PURE__ */ Z(Yn, [["__scopeId", "data-v-368c99d8"]]), Gn = ["aria-label"], Jn = /* @__PURE__ */ me({
  __name: "MultiValue",
  props: {
    label: {},
    option: {},
    classes: {},
    tagContentSlot: { type: Function }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const o = e, n = t;
    return (i, s) => (y(), A("div", {
      class: B(["multi-value", o.classes?.multiValue])
    }, [
      K("div", {
        class: B(["multi-value-label", o.classes?.multiValueLabel])
      }, [
        o.tagContentSlot ? (y(), L(_(o.tagContentSlot), {
          key: 0,
          option: o.option
        }, null, 8, ["option"])) : (y(), A(N, { key: 1 }, [
          ie(ue(o.label), 1)
        ], 64))
      ], 2),
      K("button", {
        type: "button",
        class: B(["multi-value-remove", o.classes?.multiValueRemove]),
        "aria-label": `Remove ${o.label}`,
        onClick: s[0] || (s[0] = Me((l) => n("remove"), ["stop"]))
      }, [
        Qe(et)
      ], 10, Gn)
    ], 2));
  }
}), Qn = /* @__PURE__ */ Z(Jn, [["__scopeId", "data-v-ba5b83d4"]]), eo = { class: "input-placeholder" }, to = /* @__PURE__ */ me({
  __name: "Placeholder",
  props: {
    text: {},
    placeholderSlot: { type: Function }
  },
  setup(e) {
    return (t, o) => (y(), A("div", eo, [
      e.placeholderSlot ? (y(), L(_(e.placeholderSlot), { key: 0 })) : (y(), A(N, { key: 1 }, [
        ie(ue(e.text), 1)
      ], 64))
    ]));
  }
}), no = /* @__PURE__ */ Z(to, [["__scopeId", "data-v-d650edcf"]]), oo = ["data-state"], io = ["id", "aria-expanded", "aria-describedby", "aria-description", "aria-labelledby", "aria-label", "aria-required", "aria-owns", "aria-controls"], lo = ["data-value"], so = ["id", "aria-labelledby", "disabled"], ao = /* @__PURE__ */ me({
  __name: "Select",
  props: /* @__PURE__ */ Te({
    options: {},
    displayedOptions: {},
    placeholder: { default: "Select an option" },
    isClearable: { type: Boolean, default: !0 },
    isDisabled: { type: Boolean, default: !1 },
    isSearchable: { type: Boolean, default: !0 },
    isMulti: { type: Boolean, default: !1 },
    isTaggable: { type: Boolean, default: !1 },
    isLoading: { type: Boolean, default: !1 },
    isMenuOpen: { type: Boolean, default: void 0 },
    hideSelectedOptions: { type: Boolean, default: !0 },
    shouldAutofocusOption: { type: Boolean, default: !0 },
    closeOnSelect: { type: Boolean, default: !0 },
    teleport: { default: void 0 },
    inputId: { default: void 0 },
    classes: { default: void 0 },
    uid: { default: Ut() },
    aria: { default: void 0 },
    disableInvalidVModelWarn: { type: Boolean, default: !1 },
    filterBy: { type: Function, default: (e, t, o) => t.toLowerCase().includes(o.toLowerCase()) },
    getOptionValue: { type: Function, default: (e) => e.value },
    getOptionLabel: { type: Function, default: (e) => e.label },
    inputAttrs: { default: void 0 },
    selectOnBlur: { type: Boolean, default: !0 }
  }, {
    modelValue: { required: !0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ Te(["optionSelected", "optionDeselected", "optionCreated", "menuOpened", "menuClosed", "search"], ["update:modelValue"]),
  setup(e, { expose: t, emit: o }) {
    const n = e, i = o, s = St(), l = Je(e, "modelValue"), c = Ct(), f = F(() => c.class), u = le("container"), r = le("input"), p = le("indicators"), d = X(""), a = X(!1), m = X(-1), g = F(() => {
      const h = n.displayedOptions || n.options;
      h?.length || console.warn("[vue3-select-component warn]: No options or displayedOptions were provided to the component.");
      const S = h.map((T) => ({
        ...T,
        label: n.getOptionLabel(T),
        value: n.getOptionValue(T)
      })), C = (T) => T.filter(
        (V) => n.hideSelectedOptions && Array.isArray(l.value) ? !l.value.includes(V.value) : !0
      );
      if (n.isSearchable && d.value) {
        const T = S.filter((V) => n.filterBy(V, n.getOptionLabel(V), d.value));
        return n.isMulti ? C(T) : T;
      }
      return n.isMulti ? C(S) : S;
    }), v = F(() => {
      if (n.isMulti)
        return Array.isArray(l.value) ? l.value.map((S) => n.options.find((C) => n.getOptionValue(C) === S)).filter((S) => S !== void 0) : (n.disableInvalidVModelWarn || console.warn(`[vue3-select-component warn]: The v-model provided should be an array when using \`isMulti\` prop, instead it was: ${l.value}`), []);
      const h = n.options.find((S) => n.getOptionValue(S) === l.value);
      return h ? [h] : [];
    }), w = F(() => {
      const h = {
        autocapitalize: "none",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: !1,
        tabindex: 0,
        type: "text"
      }, S = n.isSearchable ? {} : { readonly: !0, tabindex: -1, "aria-hidden": !0 };
      return {
        ...h,
        ...S,
        ...n.inputAttrs
      };
    });
    function b() {
      n.isDisabled || (a.value = !0, n.shouldAutofocusOption && (m.value = n.options.findIndex((h) => !h.disabled)), n.isSearchable && r.value && r.value.focus(), i("menuOpened"));
    }
    function x() {
      a.value = !1, d.value = "", i("search", ""), i("menuClosed");
    }
    function D() {
      a.value ? x() : b();
    }
    function k(h) {
      p.value?.containerRef && !p.value.containerRef.contains(h.target) && (a.value && d.value.length === 0 ? x() : b());
    }
    function I() {
      a.value && d.value.length === 0 ? x() : b();
    }
    const O = (h) => {
      h.disabled || (n.isMulti ? Array.isArray(l.value) ? l.value.find((C) => C === h.value) ? l.value = l.value.filter((C) => C !== h.value) : l.value = [...l.value, h.value] : (l.value = [h.value], n.disableInvalidVModelWarn || console.warn(`[vue3-select-component warn]: The v-model provided should be an array when using \`isMulti\` prop, instead it was: ${l.value}. Since an option has been selected, the component automatically converted the v-model to an array.`)) : l.value = h.value, i("optionSelected", h), d.value = "", n.closeOnSelect && x());
    }, M = (h) => {
      n.isDisabled || (n.isMulti ? Array.isArray(l.value) ? (l.value = l.value.filter((S) => S !== n.getOptionValue(h)), i("optionDeselected", h)) : n.disableInvalidVModelWarn || console.warn(`[vue3-select-component warn]: The v-model provided should be an array when using \`isMulti\` prop, instead it was: ${l.value}`) : (l.value = void 0, i("optionDeselected", h)));
    }, E = () => {
      n.isMulti ? (l.value = [], i("optionDeselected", null)) : (l.value = void 0, v.value[0] && i("optionDeselected", v.value[0])), a.value && x(), r.value && r.value.focus();
    }, W = () => {
      i("optionCreated", d.value), d.value = "", x();
    }, te = (h) => {
      m.value = h;
    }, ne = (h) => {
      h.key === "Tab" ? x() : (h.code === "Space" && !a.value && d.value.length === 0 || (h.key === "ArrowDown" || h.key === "ArrowUp") && !a.value) && (h.preventDefault(), h.stopImmediatePropagation(), b());
    }, oe = () => {
      if (n.selectOnBlur && a.value && m.value >= 0) {
        const h = g.value[m.value];
        h && !h.disabled && O(h);
      }
      x();
    };
    return _e(tt, n), _e($e, {
      vmodel: l,
      availableOptions: g,
      selectedOptions: v,
      menuOpen: a,
      focusedOption: m,
      containerRef: u,
      search: d,
      openMenu: b,
      closeMenu: x,
      toggleMenu: D,
      handleControlClick: k,
      handleInputMousedown: I,
      setOption: O,
      removeOption: M,
      createOption: W,
      setFocusedOption: te
    }), t({
      inputRef: r,
      containerRef: u,
      openMenu: b,
      closeMenu: x,
      toggleMenu: D,
      clear: E
    }), ce(
      () => d.value,
      () => {
        n.isSearchable && d.value && (i("search", d.value), a.value || b());
      }
    ), ce(
      () => n.isMenuOpen,
      (h, S) => {
        S === void 0 && h === void 0 || (h ? b() : x());
      },
      { immediate: !0 }
    ), (h, S) => (y(), A("div", {
      ref: "container",
      dir: "auto",
      class: B(["vue-select", [{ open: a.value, typing: a.value && d.value.length > 0, disabled: e.isDisabled }, n.classes?.container]]),
      "data-state": a.value ? "open" : "closed"
    }, [
      K("div", {
        class: B(["control", [{ focused: a.value, disabled: n.isDisabled }, n.classes?.control]]),
        onClick: S[2] || (S[2] = (C) => k(C))
      }, [
        K("div", {
          id: `vue-select-${e.uid}-combobox`,
          class: B(["value-container", [{ multi: e.isMulti, "has-value": v.value.length > 0 }, n.classes?.valueContainer]]),
          role: "combobox",
          "aria-expanded": a.value,
          "aria-describedby": e.placeholder,
          "aria-description": e.placeholder,
          "aria-labelledby": e.aria?.labelledby,
          "aria-label": v.value.length ? v.value.map(e.getOptionLabel).join(", ") : "",
          "aria-required": e.aria?.required,
          "aria-owns": `vue-select-${e.uid}-listbox`,
          "aria-controls": `vue-select-${e.uid}-listbox`,
          "aria-haspopup": "true"
        }, [
          !v.value[0] && !d.value.length ? (y(), L(no, {
            key: 0,
            text: e.placeholder,
            "placeholder-slot": s.placeholder,
            class: B(n.classes?.placeholder)
          }, null, 8, ["text", "placeholder-slot", "class"])) : !n.isMulti && v.value[0] ? (y(), A("div", {
            key: 1,
            class: B(["single-value", [n.classes?.singleValue]]),
            onClick: S[0] || (S[0] = (C) => b())
          }, [
            s.value ? (y(), L(_(s.value), {
              key: 0,
              option: v.value[0]
            }, null, 8, ["option"])) : (y(), A(N, { key: 1 }, [
              ie(ue(e.getOptionLabel(v.value[0])), 1)
            ], 64))
          ], 2)) : n.isMulti && v.value.length ? (y(!0), A(N, { key: 2 }, Ee(v.value, (C) => (y(), A(N, {
            key: C.value
          }, [
            s.tag ? (y(), L(_(s.tag), {
              key: 0,
              option: C,
              removeOption: () => M(C)
            }, null, 8, ["option", "removeOption"])) : (y(), L(Qn, {
              key: 1,
              label: e.getOptionLabel(C),
              option: C,
              "tag-content-slot": s["tag-content"],
              classes: {
                multiValue: n.classes?.multiValue,
                multiValueLabel: n.classes?.multiValueLabel,
                multiValueRemove: n.classes?.multiValueRemove
              },
              onRemove: (T) => M(C)
            }, null, 8, ["label", "option", "tag-content-slot", "classes", "onRemove"]))
          ], 64))), 128)) : J("", !0),
          K("div", {
            class: B(["input-container", [{ typing: a.value && d.value.length > 0 }, n.classes?.inputContainer]]),
            "data-value": d.value
          }, [
            At(K("input", kt({
              id: e.inputId,
              ref: "input",
              "onUpdate:modelValue": S[1] || (S[1] = (C) => d.value = C),
              class: ["search-input", n.classes?.searchInput]
            }, w.value, {
              "aria-autocomplete": "list",
              "aria-labelledby": `vue-select-${e.uid}-combobox`,
              disabled: e.isDisabled,
              placeholder: "",
              onMousedown: I,
              onKeydown: ne,
              onBlur: oe
            }), null, 16, so), [
              [Rt, d.value]
            ])
          ], 10, lo)
        ], 10, io),
        Qe(jt, {
          ref: "indicators",
          "has-selected-option": v.value.length > 0,
          "is-menu-open": a.value,
          "is-clearable": e.isClearable,
          "is-loading": e.isLoading,
          "is-disabled": e.isDisabled,
          slots: { clear: s.clear, dropdown: s.dropdown, loading: s.loading },
          onClear: E,
          onToggle: D
        }, null, 8, ["has-selected-option", "is-menu-open", "is-clearable", "is-loading", "is-disabled", "slots"])
      ], 2),
      (y(), L(Dt, {
        to: e.teleport,
        disabled: !e.teleport,
        defer: !0
      }, [
        a.value ? (y(), L(Zn, {
          key: 0,
          modelValue: l.value,
          "onUpdate:modelValue": S[3] || (S[3] = (C) => l.value = C),
          "root-class": f.value,
          slots: {
            option: s.option,
            "menu-header": s["menu-header"],
            "no-options": s["no-options"],
            "taggable-no-options": s["taggable-no-options"]
          }
        }, null, 8, ["modelValue", "root-class", "slots"])) : J("", !0)
      ], 8, ["to", "disabled"]))
    ], 10, oo));
  }
}), co = /* @__PURE__ */ Z(ao, [["__scopeId", "data-v-80a1bde4"]]);
export {
  co as default
};
